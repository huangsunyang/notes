#### 静态连接

- 在编译目标文件的时候搁置引用其他文件中全局变量的地址，在链接的时候通过符号决议（Symbol Resolution）以及重定位（Relocation）等步骤将符号的地址进行修正
- 疑惑：所有变量都需要重定位吗？肯定不是。如何确定一个变量的地址？栈空间的变量似乎可以确定。堆空间变量的地址是运行时分配的。

#### 目标文件里有什么

- objdump命令与size命令，size命令-A选项使用本地系统格式。查看目标文件头与各个section内容

##### 汇编指令回顾

- 函数参数和函数返回地址保存在caller的函数栈内，callee函数栈的起点保存着caller的%ebp，这也就是函数开头的`push %ebp; mov %esp %ebp`所做的事情。`%ebp`永远指向当前函数栈的起点，也就是最高地址处；而`%esp`则随着`push`和`pop`指令动态变化，永远指向当前函数栈底。
- `call x`指令相当于`push %eip; jump x`，将当前指令地址入栈，并跳转到目标函数地址；同理，`ret`指令也就是`pop %eip`，也就是跳转到当前栈位置的地址中去。

##### .bss段

- 未初始化或者初始化为0的静态变量会被存放在.bss（block started by symbol）段，bss本来是一条指令，用来给未初始化的符号分配空间；初始化了的全局变量则会放在.data段。

##### elf（Executable and Linkable Format）文件结构

- 会有什么呢？
  - magic/类型（可执行/可重定位/动态链接库）/32/64位/大小端/版本/文件头大小
  - 程序入口虚拟地址
  - 段表在文件中的偏移/段表描述符大小/数量
  - 段表字符串表索引（在段表中的序号）

##### 段表 （Section Header Table）

- `objdump -h`显示段信息不全，windows上不知道用啥工具.. linux通常使用`readelf -S`
- `readelf -S`显示的每一行就是一个段描述符`Elf32_Shdr`(Section Header Descriptor)，包括：
  - 段名/类型/标志位
  - 虚拟地址/文件中偏移/段长度
  - 段连接信息
  - 段地址对齐字节数，用指数表示
  - 段中每个项的大小（对项目大小固定的段有用）
  - 重定位表信息作用于哪个段（下标）

- 段的名字无用，有用的是段的类型和标志位

##### 重定位表

- `.rel.text`段，类型为`SHT_REL`即标志该段包含重定位信息。这个名字表明这是针对`.text`段的重定位表，比如对函数的重定位（`printf`等）。`.rel.data`即是针对`.data`段的重定位表，也就是对外部变量的重定位。
- 疑惑？符号表是啥，和重定位表什么关系？

##### 字符串表

- 分为字符串表`.strtab`和段表字符串表`.shstrtab`。前者用来保存普通的字符串，比如变量名；后者用来保存段表中用到的字符串，比如段名
- 疑惑？为何说从ELF头获得了段表字符串表序号后就能够解析整个ELF文件？

##### 符号表

- 函数名/变量名就是**符号**，符号的分类如下：
  - 本目标文件的全局符号，可被其他文件引用。全局函数，全局变量（无static声明）
  - 外部符号。即非本目标文件的符号，引用的全局符号
  - 段名/局部符号/行号信息

- 符号表结构：
  - 符号名（字符串表中的下标）
  - 符号值（在所在段中的偏移/对齐属性/虚拟地址）
  - 符号大小
  - 符号类型和绑定信息（数据/函数/段/文件名）（局部符号/全局符号/弱引用）
  - 符号所在段（可能会有特殊情况，比如文件名/未初始化全局符号，其不在任何一个段中）

##### 符号修饰与函数签名

- 编译器如何区分不同目标文件/命名空间中的同名变量，重载函数? - 符号修饰
- Unix C++中的符号修饰
  - `_ZN5Class4funcEi`
  - `_Z`为所有符号的前缀，如果符号在命名空间/类内，则以`_ZN...E`形式
  - 中间省略处以此写上命名空间的名称，名称写需要写字符串长度
  - c++filt工具可以用来解析修饰过的符号
- 不同编译器生成的修饰符号通常也是不同的，所以不能互相链接！

##### extern "C“

- `extern "C" { stat }`语句块中的部分会被当做C代码处理，其中的符号修饰方式与C++不同。
- 运行库目标文件中的符号自然是以C语言的标准修饰的，C++如果想要兼容C语言的目标文件，就需要将头文件放置在`extern "C" { stat }`代码块中，通常都会用`__cplusplus`宏来处理代码块

##### 强符号/弱符号

- 强弱符号用来处理目标文件中名称冲突的问题
- 强弱符号是针对定义而言的，全局变量为强符号，未初始化的全局变量为弱符号

- 符号冲突原则：
  - 多个目标文件中都有强符号，报错
  - 一个目标文件中有强符号，其他都是弱符号，取强符号
  - 都是弱符号，取占用空间最大的...
- 弱符号和弱引用的作用
  - 用户自定义强符号覆盖库中的若符号
  - 用户自定弱符号，判断弱符号是否被覆盖，从而判断是否使用了某个库

### 静态连接

#### 空间地址分配

- 分配可执行文件中的空间和装载到内存中的虚拟地址空间

- 多个目标文件如何合并成一个可执行文件的？
- 各个段是如何合并的？
  - 直接将段放在一起？可行，但是不好。由于字节对齐的原因，每个段都会4096字节对齐
  - 将相似段/相同段合并为一个段。

- 两步链接 Two-pass Linking
  - 空间与地址分配
  - 符号解析与重定位

#### 符号解析与重定位

- 经过链接之后，原本空置为0x0的地址获得了正确的地址，这是通过重定位表来实现的
- 重定位表是一个`Elf32_Rel`结构的数组，每一项包含：
  - 重定位入口的偏移。相对于段起始的偏移（可重定位文件）/ 入口需要修正的位置的虚拟地址（可执行文件/共享对象文件）。虽说书中还没提到，还是能够理解的，动态链接自然是在运行时刻去查找重定位表来修正地址的，而静态链接在链接时刻就可以确定，所以用的是文件中的偏移。
  - 重定位入口的类型（低8位）的符号表中的下标（高24位）。

- 保留的占位值是什么？
  - 比如引用的是数组中的元素，就会把偏移保留在原位？
  - 符合地址修正的时候会加上符号表中的符号地址信息
  - 如果是相对寻址修正，还需要减去该处位置相对于段的偏移
- 如何判断是相对/绝对寻址修正呢？
  - 通过指令来判断，有的指令接收的就是绝对地址，有的就是相对地址。

#### COMMON块

- 为何不将**未初始化的全局变量**分配在.bss段呢？
  - 因为这是一个弱符号，在链接之前不能知道弱符号的大小因此无法分配空间
  - 多个弱符号冲突的时候会选择大小最大的
  - 最终生成可执行文件的时候还是被放在bss段的

#### C++相关问题

##### 重复代码消除

- 模板/内联函数/虚函数表都会在不同的编译单元里生成相同代码
- 重复代码会有一下问题：
  - 浪费空间
  - 同样的函数指针不相同
  - 缓存命中率降低

- 不同类型实例化的模板函数放在不同的段内，链接的时候取一个
  - 不同的编译单元编译出的结果可能不同.. 链接器会随便选一个，给警告信息

##### 全局构造与析构

- 全局对象的构造函数在main之前被执行，析构函数在main之后被执行

- linux下的程序入口一般是`_start`，其中会调用`main`函数，`.init`段和`.fini`段分别会在`main`前后执行

##### C++与ABI

- 能够链接不同编译器生成的目标文件？
  - 需要链接器能识别这两种格式
  - 两个目标文件需要有相同的符号修饰标准/内存分布方式/函数调用方式等等
  - 这些与可执行代码二进制兼容性相关的内容称为ABI（Application Binary Interface）
    - 内置类型/组合类型的大小和存储方式
    - 外部符号的命名方式和解析方式
    - 函数调用方式/堆栈分布方式/参数传递方式
    - 寄存器使用约定
    - 继承类体系的内存分布
    - 指向成员函数的指针的内存分布
    - 虚表在对象中的位置
    - 模板如何实例化
    - 全局对象的构造和析构
    - 异常的产生和捕获机制
    - RTTI如何实现

#### 静态库链接

- `gcc hello.c -o hello`的执行过程
  - cc1将`hello.c`编译成.s文件
  - as汇编器将其汇编成.o文件
  - 最后调用了collect2完成链接
- collect2可以看作是ld链接器的一个包装
- 为何目标文件中的函数很少？每个.o库中只有一个函数？
  - 不链接未使用的函数

#### 链接过程控制

##### 链接控制脚本

- 怎么来控制链接的过程呢？
  - 命令行参数/PE/COFF中的`.drectve`段/链接控制脚本



### Windows PE/COFF

- Portable Executable/Common Object File Format



### 可执行文件的装载与进程

#### 进程虚拟地址空间

##### PAE(`Physical Address Extension`)

- 32位CPU能够使用超过4GB的空间？
  - 虚拟地址只能有32位，但是可能通过`AWE`(`Address Windowing Extensions`)/`mmap`映射到2^32之外的空间

#### 装载的方式

##### 覆盖装入 (`Overlay`)

- 任取程序运行中的一个时刻，当前的调用栈中函数所在模块的集合也就是**调用路径**，确保每个时刻调用路径中的模块都在内存中即可；同时，不在调用路径中的模块也就可以被移出内存。

##### 页映射

- `IA32`架构处理器一页=4096字节，也就是4KB
- FIFO/LRU...

#### 从操作系统角度看可执行文件的装载

- 创建虚拟地址空间，建立虚拟空间与物理空间的映射关系
  - 本质上只是分配一个页目录（`Page Directory`)
- 读取文件头，建立虚拟空间与可执行文件的映射关系
  - 虚拟地址的缺页错误，从内存中分配物理页并读取（装载）
  - `VMA`(`Virtual Memeory Area`)/(`Virtual Section`)，及整个映射关系的存放位置

#### 进程虚拟空间分布

##### 文件链接视图和执行视图

- 从不同的角度来理解可执行文件的格式

- section与segment
  - elf文件是以section为单位存储的，但是载入内存空间时，以页大小为单位容易产生冗余空间，因此在可执行文件中，会将类型（读/写/执行）相同的section放在一起形成segment，同一个segment会被一起加载到内存空间中
- Program Header Table
  - 由于目标文件不需要被装载，所以没有该表
  - 类型：LOAD/DYNAMIC/INTERP
  - 文件中的偏移/虚拟地址空间位置/物理装载地址
  - 文件中的段大小/虚拟空间中的段大小/对齐属性
    - 虚拟空间大小如果大于文件中的段大小，额外部分可能就是.bss段，因为其被合并到了.data段，而其唯一区别就是没有初始值，所以不用占用文件空间

##### 堆和栈

- VMA处理可用来映射可执行文件中的Segment之外，还用来管理堆栈、
- Anonymous VMA用来映射堆栈还有vdso，其没有对应的文件
  - 堆向上扩展/栈向下扩展

##### 段地址对齐（仅限ELF格式，PE格式的section都会以页大小对齐，甚至没有segment的概念）

- segment并不是以页大小对齐属性对齐的（但是4字节对齐还是要的），为什么呢？可能每个segment都很小，如果按对齐属性对齐就会浪费空间
- 如果多个segment合并在一起，可以将包含多个segment的那个页重复映射到虚拟地址中即可。这会使得虚拟地址空间增多，但是物理地址空间会节省。
- 注意，只有可执行文件可以合并段。共享文件的文件内和虚拟地址空间内的布局需要相同，因为共享文件需要生成地址无关代码。

##### 进程栈初始化

- 环境变量/main的参数

#### linux内核装载ELF过程简介

- bash进程会调用fork()系统调用创建一个新的进程；新的进程调用`execve()`系统调用执行指定的ELF文件；bash进程等待启动的新进程结束。`execve`的参数也就是文件名/执行参数/环境变量，也就是进程栈初始化中的值
- `execve`调用`sys_execve`检查参数后会调用`do_execve`，`do_execve`会找到可执行文件并检查文件头，用对应格式的装载器来装载文件，efl文件对应的装载函数为`load_elf_binary`，其中:
  - 检查文件有效性
  - 寻找动态链接的`.interp`段
  - 根据`programm header table`的描述，对ELF文件进行映射
  - 初始化ELF进程环境
  - 将系统调用的返回地址修改为ELF可执行文件的入口点
  - 返回用户态后`EIP`已经跳转到ELF文件的入口地址，新的程序就开始执行了

#### Windows PE的装载

- 链接器生成可执行文件的时候，会尽量把所有段合并，一般只有代码段/数据段/只读数据段/BSS段这几个

- RVA`(Relative Virtual Address`)即相对于装载目标地址（`Target Address`）的偏移

- 装载过程相对ELF文件简单：

  - 先读取第一个页，包含了DOS头，PE文件头和段表
  - 检查进程地址空间中，目标地址是否可用（可执行文件一般都可用，dll文件可能需要`rebasing`）
  - 使用段表中提供的信息，将PE文件中所有段映射到虚拟空间中的相应位置
  - 装载PE文件所需要的DLL文件
  - 对PE文件中的导入符号进行解析
  - 根据PE头中指定的参数建立和初始化堆栈
  - 建立主线程并启动进程

- PE Optional Header中的一些参数包括

  - 装载地址
  - 程序入口点，即第一条指令的`RVA`
  - 内存段对齐粒度/文件段对齐粒度

  - 版本/文件大小/头+节表大小/子系统（GUI/控制台）
  - 代码段长度/data段长度/`bss`段长度
  - 代码段rva/数据段rva

### 动态链接

#### 为什么要动态链接

- 静态链接的问题？
  - 浪费内存和磁盘空间，因为使用的目标文件都被复制到了可执行文件中去了
  - 程序开发和发布。更新目标文件后需要重新链接发布

##### 动态链接的思路

- 解决上述问题，将程序的模块相互分割开来，形成独立的文件，将链接的过程推迟到运行时再进行

##### 程序的可扩展性和兼容性

- 可以在运行时动态地选择加载各种程序模块，也就是后来制作程序的插件
- 但是还是会有新旧模块之间的接口不兼容的问题

##### 动态链接的基本实现

- `.so`文件`Dynamic Shared Objects`/`.dll`文件`Dynamical Linking Library`
- 将链接的过程推迟到了运行时，性能问题？延迟绑定`Lazy Binding`等方法

#### 地址无关代码

##### 固定装载地址的困扰

- 共享对象在被装载的时候，如何确定在进程虚拟地址空间中的位置？
- 共享对象在编译时不能假设自己在进程虚拟地址空间中的位置！
- 可执行文件基本可以确定，因为往往是第一个被加载的

##### 装载时重定位 Load Time Relocation

- Windows称为基址重置 `Rebasing`
- 静态链接时的重定位为链接时重定位 `Link Time Relocation`
- 具体操作是在装载时通过重定位表去更改引用符号的地址
- 问题？共享的指令部分无法在多个进程间共享，因为重定位会更改指令的代码

##### 地址无观代码

- `-fPIC`什么意思？`Position-Independent Code`即地址无关代码

- 四种情况：模块内部/外部的函数/数据访问
- 模块内部调用或跳转
  - 使用当前指令地址与目标地址之间的差值，即相对地址指令调用
  - 存在问题？共享对象全局符号介入 Global Symbol Interposition

- 模块内部数据访问
  - 和前者类似，但是通常没有用相对地址访问数据的指令
  - ELF中只用一种巧妙方案获得当前PC值加上偏移，就达到了该目的
    - call一个新函数，函数内仅仅时将当前的`%esp`即栈顶对象放入寄存器
    - 因为call指令就是将下一条指令地址放入栈顶，也就通过了这种方式获得了PC值

- 模块间数据访问
  - 模块间的数据访问目标地址需要等到装载的时候才能决定，因此无法直接使用偏移决定
  - 数据段中的全局偏移表 `Global Offset Table`，其中存放着这些外部数据的地址，这些地址会在装载的时候被填充。注意：这个实现能够成立的原因是不同程序加载同一个共享文件会有独立的数据段副本
  - 注意GOT中项目地址的确定也就是**模块内部的数据访问**
- 模块间调用或跳转
  - 同样使用GOT即可

##### 共享模块的全局变量问题

- 如果可执行文件中使用`extern`关键字引用了共享文件中的变量，由于其没有重定位，就会在`.bss`段创建一个副本（弱符号决议？）最后被装载到虚拟地址空间中的data段，初始化为0。
- 当共享文件中使用这个变量的时候，怎么同时改变这个副本呢？
  - 所有使用这个变量的指令全都指向这个副本
  - 共享文件内的全局变量默认当作定义在其他模块中的全局变量，即全都通过GOT访问

##### 数据地址无关性

- 装载时重定位，通过重定位表中`R_386_RELATIVE`类型的重定位入口
- 数据段有副本，因此无所谓

#### 延迟绑定 PLT

- 动态链接的性能劣势，相比静态链接慢1%-5%
  - 使用GOT进行间接寻址
  - 运行时的链接开销

- 函数第一次用到时再进行绑定（符号查找，重定位）
  - PLT `Procedure Linkage Table`
  - 将函数的间接地址从`.got`中移出，放到`.got.plt`中，`.got.plt`中包含头部：
    - `.dynamic`段地址
    - 当前模块名
    - `_dll_runtime_resolve`函数地址，即用来定位函数地址的函数
  - `.plt`的每一项都是三条指令（第一项是通用指令，只有两条）
    - 通用代码`push *(.got.plt + 4);jump *(.got.plt + 8)`
    - `jump *(bar@GOT);push n;jump PLT0`
    - n为符号表中的下标，实际上也就是用n和模块名当作参数传给了`_dll_runtime_resolve`函数调用
    - 估计重定位成功后会将`push n;jump PLT0`这两条指令删除，因为函数地址已经保存再`bar@GOT`中了。而在此之前，其中填写的也就是`push n`这条指令的地址

#### 动态链接相关结构

- 动态链接器 `Dynamic Linker`
  - 再装载完可执行文件之后，并不能将控制权交给可执行文件，因为其中还有很多函数地址处于无效状态。此时会先启动动态链接器，并将控制权交给它。
  - 动态链接器工作完成会，控制权会交换给可执行文件
  - linux中实际上就是一个共享对象`ld.so`

##### `.interp`段

- 指向动态链接器的路径，linux上通常是一个软链接`/lib/ld.so`

##### `.dynamic`段

- 相当于动态链接的文件头，说实话有点丑陋
- 每一项都是类型-值的结构体

##### 动态符号表 .dynsym

- 导入函数和导出函数，即所使用的其他库的函数以及供其他库使用的函数
- 动态符号表用来保存模块之间的导入导出关系，其只保存与动态链接相关的符号（.symtab中保存所有符号）
- `.dynstr`段保存了动态符号字符串；`.hash`段保存了符号哈希

##### 动态链接重定位表

- 不使用PIC编译的共享文件肯定是需要重定位的，但是使用了PIC的共享文件，其中的.data段如果引用了绝对地址，也需要重定位
- `.rel.dyn`以及`.rel.plt`分别是对数据引用的修正以及对函数引用的修正

##### 重定位表相关结构

- R_386_GLOB_DAT/R_386_JUMP_SLOT，只需要直接填入的地址即可。因为只需要重定位`.glt`表中的地址即可，反而操作更简单

##### 动态链接时进程堆栈初始化信息

- 链接器需要的数据会由操作系统保存在进程的堆栈里
  - 包括执行环境和命令行参数等
  - 辅助信息组`Auxiliary Vector`，也是一个类型-值的结构体数组
    - `AT_NULL`辅助信息数组结束
    - `AT_EXEFD`表示可执行文件的文件句柄，可访问可执行文件
    - `AT_PHDR`表示可执行文件中的程序头表`Program Header`在进程中的地址
    - `AT_PHENT`表示程序头表中每个入口的大小
    - `AT_PHNUM`表示程序头表中入口的数量
    - `AT_BASE`表示动态链接器本身的装载地址
    - `AT_ENTRY`表示可执行文件的入口地址，即启动地址

#### 动态链接的步骤和实现

##### 动态链接器自举 Bootstrap

- 动态链接器不应该依赖其他共享对象
- 动态链接器本身所需要的全局和静态变量的重定位工作由它本身完成
  - 先找到自己的GOT，第一项为`.dynamic`段，从而获得重定位表和符号表以及本身的重定位入口
  - 此后才能使用全局变量和静态变量

##### 装载共享对象

- 找到所有符号表，即全局符号表。可执行文件编译的时候.dynamic段中由依赖的共享对象的数据。连机器由此可找到相应的文件，将其代码段和数据段映射到进程空间。其符号同时也会合并到全局符号表中。

##### 符号优先级

- 全局符号介入 `Global Symbol Interpose`
- 全局符号表中后加入的同名符号会被忽略
- 调用模块内的非静态函数，由于可能会被全局符号覆盖，无法直接使用`PIC`，仍需要使用`.got.plt`

#### 重定位和初始化

- 链接器开始遍历可执行文件和每个共享对象的重定位表，修正其中的GOT/PLT段
- 执行共享对象中的`.init`段中的代码，例如共享对象中C++的全局/静态对象构造。注意可执行文件的`.init`段不会被执行
- 动态链接器将控制权交还给程序

#### Linux动态链接器实现

#### 显示运行时链接 `Explicit Run-time Linking`

- `dlopen`载入一个共享文件，可选择是否使用延迟绑定，以及是否载入全局变量。返回模块句柄，如果模块之间有依赖关系，需要手工加载被依赖的模块
- `dlsym`接收句柄和符号名
  - 如果找到了函数/变量，返回函数地址
  - 如果找到了常量，返回常量的值

### Linux共享库组织

#### 共享库版本

##### 共享库兼容性

- 导致C语言共享库ABI改变的行为主要有

  - 函数行为变化

  - 函数被删除
  - 函数参数/返回值变化
  - 导出数据结构变化

##### 共享库命名

- libname.so.x.y.z
  - x为主版本号，不同主版本号之间的库时不兼容的
  - y为次版本号，向后兼容
  - z为发布版本号，完全兼容

##### SO-NAME和链接名

- 程序依赖的共享库名，即共享库的文件名去掉了次版本号和发布版本号
- Linux中会为每个共享库在所在目录创建一个SO-NAME命名的软链接
- 链接名，即libXXX中的XXX

### Windows下的动态链接

#### DLL简介

- dll文件的扩展名不一定是.dll，也可能是`.ocx`控件或者`.CPL`控制面板程序
- 设计目的 - 强调模块化

##### 进程地址控件和内存管理

##### 基地址和RVA

- 基地址`Image Base`是进程地址空间中的起始地址，对于EXE来说一般是0x400000；对于DLL文件来说一般是0x10000000。
- 相对地址`Relative Virtual Address`就是一个地址相对于基地址的偏移

##### DLL共享数据段

- win32下实现进程间通信的方法：
  - 使用DLL来实现进程间通信。允许将DLL的数据段设置为共享的

##### DLL的简单例子

- ELF中，共享库中的所有全局函数和变量在默认情况下都可以被其他模块使用，也就是说ELF默认导出全局符号。而DLL需要显示地告诉编译器我们需要某个符号。
- 使用`__declspec(dllexport)`
- 使用链接器的链接脚本文件，其中指明IMPORT和EXPORTS段声明导入导出符号

##### 创建DLL

- 使用`cl /LD a.c`生成dll，这会生成a.dll，a.obj，a.exp，a.lib（导入库）四个文件

- `cl /c b.c`表示只编译不链接b.c，b.c中使用了a.dll中的函数，需要用`__declspec(import)`指明
- `link b.obj a.lib`完成了链接操作

##### 使用模块定义文件

- .def文件，可以指明EXPORT和IMPORT的函数名

##### DLL显式运行时链接

- `LoadLibrary` - `dlopen`
- `GetProcAddress` - `dlsym`
- `FreeLibrary` - `dlclose`

#### 符号导出导入表

##### 导出表

- 在DataDirectory结构数组的第一项就是导出表的的结构的地址和长度
  - 导出地址表 `Export Address Table`
  - 符号名表 `Name Table`
  - 名字序号对应表 `Name-Ordinal Table`
- 序号 `Ordinals`
  - 函数在EAT的下标加上Base就是序号值
  - 用序号来找函数更快，但是不直观，现在都用名字来找了

##### EXP文件

- 创建DLL时的临时文件，其中存放了所有的导出符号信息，以及DLL的导出表
- 第一遍生成exp文件，第二遍和其他obj一起链接生成dll文件





