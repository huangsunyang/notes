#### 静态连接

- 在编译目标文件的时候搁置引用其他文件中全局变量的地址，在链接的时候通过符号决议（Symbol Resolution）以及重定位（Relocation）等步骤将符号的地址进行修正
- 疑惑：所有变量都需要重定位吗？肯定不是。如何确定一个变量的地址？栈空间的变量似乎可以确定。堆空间变量的地址是运行时分配的。

#### 目标文件里有什么

- objdump命令与size命令，size命令-A选项使用本地系统格式。查看目标文件头与各个section内容

##### 汇编指令回顾

- 函数参数和函数返回地址保存在caller的函数栈内，callee函数栈的起点保存着caller的%ebp，这也就是函数开头的`push %ebp; mov %esp %ebp`所做的事情。`%ebp`永远指向当前函数栈的起点，也就是最高地址处；而`%esp`则随着`push`和`pop`指令动态变化，永远指向当前函数栈底。
- `call x`指令相当于`push %eip; jump x`，将当前指令地址入栈，并跳转到目标函数地址；同理，`ret`指令也就是`pop %eip`，也就是跳转到当前栈位置的地址中去。

##### .bss段

- 未初始化或者初始化为0的静态变量会被存放在.bss（block started by symbol）段，bss本来是一条指令，用来给未初始化的符号分配空间；初始化了的全局变量则会放在.data段。

##### elf（Executable and Linkable Format）文件结构

- 会有什么呢？
  - magic/类型（可执行/可重定位/动态链接库）/32/64位/大小端/版本/文件头大小
  - 程序入口虚拟地址
  - 段表在文件中的偏移/段表描述符大小/数量
  - 段表字符串表索引（在段表中的序号）

##### 段表 （Section Header Table）

- `objdump -h`显示段信息不全，windows上不知道用啥工具.. linux通常使用`readelf -S`
- `readelf -S`显示的每一行就是一个段描述符`Elf32_Shdr`(Section Header Descriptor)，包括：
  - 段名/类型/标志位
  - 虚拟地址/文件中偏移/段长度
  - 段连接信息
  - 段地址对齐字节数，用指数表示
  - 段中每个项的大小（对项目大小固定的段有用）
  - 重定位表信息作用于哪个段（下标）

- 段的名字无用，有用的是段的类型和标志位

##### 重定位表

- `.rel.text`段，类型为`SHT_REL`即标志该段包含重定位信息。这个名字表明这是针对`.text`段的重定位表，比如对函数的重定位（`printf`等）。`.rel.data`即是针对`.data`段的重定位表，也就是对外部变量的重定位。
- 疑惑？符号表是啥，和重定位表什么关系？

##### 字符串表

- 分为字符串表`.strtab`和段表字符串表`.shstrtab`。前者用来保存普通的字符串，比如变量名；后者用来保存段表中用到的字符串，比如段名
- 疑惑？为何说从ELF头获得了段表字符串表序号后就能够解析整个ELF文件？

##### 符号表

- 函数名/变量名就是**符号**，符号的分类如下：
  - 本目标文件的全局符号，可被其他文件引用。全局函数，全局变量（无static声明）
  - 外部符号。即非本目标文件的符号，引用的全局符号
  - 段名/局部符号/行号信息

- 符号表结构：
  - 符号名（字符串表中的下标）
  - 符号值（在所在段中的偏移/对齐属性/虚拟地址）
  - 符号大小
  - 符号类型和绑定信息（数据/函数/段/文件名）（局部符号/全局符号/弱引用）
  - 符号所在段（可能会有特殊情况，比如文件名/未初始化全局符号，其不在任何一个段中）

##### 符号修饰与函数签名

- 编译器如何区分不同目标文件/命名空间中的同名变量，重载函数? - 符号修饰
- Unix C++中的符号修饰
  - `_ZN5Class4funcEi`
  - `_Z`为所有符号的前缀，如果符号在命名空间/类内，则以`_ZN...E`形式
  - 中间省略处以此写上命名空间的名称，名称写需要写字符串长度
  - c++filt工具可以用来解析修饰过的符号
- 不同编译器生成的修饰符号通常也是不同的，所以不能互相链接！

##### extern "C“

- `extern "C" { stat }`语句块中的部分会被当做C代码处理，其中的符号修饰方式与C++不同。
- 运行库目标文件中的符号自然是以C语言的标准修饰的，C++如果想要兼容C语言的目标文件，就需要将头文件放置在`extern "C" { stat }`代码块中，通常都会用`__cplusplus`宏来处理代码块

##### 强符号/弱符号

- 强弱符号用来处理目标文件中名称冲突的问题
- 强弱符号是针对定义而言的，全局变量为强符号，未初始化的全局变量为弱符号

- 符号冲突原则：
  - 多个目标文件中都有强符号，报错
  - 一个目标文件中有强符号，其他都是弱符号，取强符号
  - 都是弱符号，取占用空间最大的...
- 弱符号和弱引用的作用
  - 用户自定义强符号覆盖库中的若符号
  - 用户自定弱符号，判断弱符号是否被覆盖，从而判断是否使用了某个库

### 静态连接

#### 空间地址分配

- 分配可执行文件中的空间和装载到内存中的虚拟地址空间

- 多个目标文件如何合并成一个可执行文件的？
- 各个段是如何合并的？
  - 直接将段放在一起？可行，但是不好。由于字节对齐的原因，每个段都会4096字节对齐
  - 将相似段/相同段合并为一个段。

- 两步链接 Two-pass Linking
  - 空间与地址分配
  - 符号解析与重定位

#### 符号解析与重定位

- 经过链接之后，原本空置为0x0的地址获得了正确的地址，这是通过重定位表来实现的
- 重定位表是一个`Elf32_Rel`结构的数组，每一项包含：
  - 重定位入口的偏移。相对于段起始的偏移（可重定位文件）/ 入口需要修正的位置的虚拟地址（可执行文件/共享对象文件）。虽说书中还没提到，还是能够理解的，动态链接自然是在运行时刻去查找重定位表来修正地址的，而静态链接在链接时刻就可以确定，所以用的是文件中的偏移。
  - 重定位入口的类型（低8位）的符号表中的下标（高24位）。

- 保留的占位值是什么？
  - 比如引用的是数组中的元素，就会把偏移保留在原位？
  - 符合地址修正的时候会加上符号表中的符号地址信息
  - 如果是相对寻址修正，还需要减去该处位置相对于段的偏移
- 如何判断是相对/绝对寻址修正呢？
  - 通过指令来判断，有的指令接收的就是绝对地址，有的就是相对地址。

#### COMMON块

- 为何不将**未初始化的全局变量**分配在.bss段呢？
  - 因为这是一个弱符号，在链接之前不能知道弱符号的大小因此无法分配空间
  - 多个弱符号冲突的时候会选择大小最大的
  - 最终生成可执行文件的时候还是被放在bss段的

#### C++相关问题

##### 重复代码消除

- 模板/内联函数/虚函数表都会在不同的编译单元里生成相同代码
- 重复代码会有一下问题：
  - 浪费空间
  - 同样的函数指针不相同
  - 缓存命中率降低

- 不同类型实例化的模板函数放在不同的段内，链接的时候取一个
  - 不同的编译单元编译出的结果可能不同.. 链接器会随便选一个，给警告信息

##### 全局构造与析构

- 全局对象的构造函数在main之前被执行，析构函数在main之后被执行

- linux下的程序入口一般是`_start`，其中会调用`main`函数，`.init`段和`.fini`段分别会在`main`前后执行

##### C++与ABI

- 能够链接不同编译器生成的目标文件？
  - 需要链接器能识别这两种格式
  - 两个目标文件需要有相同的符号修饰标准/内存分布方式/函数调用方式等等
  - 这些与可执行代码二进制兼容性相关的内容称为ABI（Application Binary Interface）
    - 内置类型/组合类型的大小和存储方式
    - 外部符号的命名方式和解析方式
    - 函数调用方式/堆栈分布方式/参数传递方式
    - 寄存器使用约定
    - 继承类体系的内存分布
    - 指向成员函数的指针的内存分布
    - 虚表在对象中的位置
    - 模板如何实例化
    - 全局对象的构造和析构
    - 异常的产生和捕获机制
    - RTTI如何实现

#### 静态库链接

- `gcc hello.c -o hello`的执行过程
  - cc1将`hello.c`编译成.s文件
  - as汇编器将其汇编成.o文件
  - 最后调用了collect2完成链接
- collect2可以看作是ld链接器的一个包装
- 为何目标文件中的函数很少？每个.o库中只有一个函数？
  - 不链接未使用的函数

#### 链接过程控制

##### 链接控制脚本

- 怎么来控制链接的过程呢？
  - 命令行参数/PE/COFF中的`.drectve`段/链接控制脚本



### Windows PE/COFF

- Portable Executable/Common Object File Format



### 可执行文件的装载与进程

