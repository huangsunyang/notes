#### 静态连接

- 在编译目标文件的时候搁置引用其他文件中全局变量的地址，在链接的时候通过符号决议（Symbol Resolution）以及重定位（Relocation）等步骤将符号的地址进行修正
- 疑惑：所有变量都需要重定位吗？肯定不是。如何确定一个变量的地址？栈空间的变量似乎可以确定。堆空间变量的地址是运行时分配的。

#### 目标文件里有什么

- objdump命令与size命令，size命令-A选项使用本地系统格式。查看目标文件头与各个section内容

##### 汇编指令回顾

- 函数参数和函数返回地址保存在caller的函数栈内，callee函数栈的起点保存着caller的%ebp，这也就是函数开头的`push %ebp; mov %esp %ebp`所做的事情。`%ebp`永远指向当前函数栈的起点，也就是最高地址处；而`%esp`则随着`push`和`pop`指令动态变化，永远指向当前函数栈底。
- `call x`指令相当于`push %eip; jump x`，将当前指令地址入栈，并跳转到目标函数地址；同理，`ret`指令也就是`pop %eip`，也就是跳转到当前栈位置的地址中去。

##### .bss段

- 未初始化或者初始化为0的静态变量会被存放在.bss（block started by symbol）段，bss本来是一条指令，用来给未初始化的符号分配空间；初始化了的全局变量则会放在.data段。

##### elf（Executable and Linkable Format）文件结构

- 会有什么呢？
  - magic/类型（可执行/可重定位/动态链接库）/32/64位/大小端/版本/文件头大小
  - 程序入口虚拟地址
  - 段表在文件中的偏移/段表描述符大小/数量
  - 段表字符串表索引（在段表中的序号）

##### 段表 （Section Header Table）

- `objdump -h`显示段信息不全，windows上不知道用啥工具.. linux通常使用`readelf -S`
- `readelf -S`显示的每一行就是一个段描述符`Elf32_Shdr`(Section Header Descriptor)，包括：
  - 段名/类型/标志位
  - 虚拟地址/文件中偏移/段长度
  - 段连接信息
  - 段地址对齐字节数，用指数表示
  - 段中每个项的大小（对项目大小固定的段有用）
  - 重定位表信息作用于哪个段（下标）

- 段的名字无用，有用的是段的类型和标志位

##### 重定位表

- `.rel.text`段，类型为`SHT_REL`即标志该段包含重定位信息。这个名字表明这是针对`.text`段的重定位表，比如对函数的重定位（`printf`等）。`.rel.data`即是针对`.data`段的重定位表，也就是对外部变量的重定位。
- 疑惑？符号表是啥，和重定位表什么关系？

##### 字符串表

- 分为字符串表`.strtab`和段表字符串表`.shstrtab`。前者用来保存普通的字符串，比如变量名；后者用来保存段表中用到的字符串，比如段名
- 疑惑？为何说从ELF头获得了段表字符串表序号后就能够解析整个ELF文件？

##### 符号表

- 函数名/变量名就是**符号**，符号的分类如下：
  - 本目标文件的全局符号，可被其他文件引用。全局函数，全局变量（无static声明）
  - 外部符号。即非本目标文件的符号，引用的全局符号
  - 段名/局部符号/行号信息

- 符号表结构：
  - 符号名（字符串表中的下标）
  - 符号值（在所在段中的偏移/对齐属性/虚拟地址）
  - 符号大小
  - 符号类型和绑定信息（数据/函数/段/文件名）（局部符号/全局符号/弱引用）
  - 符号所在段（可能会有特殊情况，比如文件名/未初始化全局符号，其不在任何一个段中）

##### 符号修饰与函数签名

- 编译器如何区分不同目标文件/命名空间中的同名变量，重载函数? - 符号修饰
- Unix C++中的符号修饰
  - `_ZN5Class4funcEi`
  - `_Z`为所有符号的前缀，如果符号在命名空间/类内，则以`_ZN...E`形式
  - 中间省略处以此写上命名空间的名称，名称写需要写字符串长度
  - c++filt工具可以用来解析修饰过的符号
- 不同编译器生成的修饰符号通常也是不同的，所以不能互相链接！

##### extern "C“

- `extern "C" { stat }`语句块中的部分会被当做C代码处理，其中的符号修饰方式与C++不同。
- 运行库目标文件中的符号自然是以C语言的标准修饰的，C++如果想要兼容C语言的目标文件，就需要将头文件放置在`extern "C" { stat }`代码块中，通常都会用`__cplusplus`宏来处理代码块

##### 强符号/弱符号

- 强弱符号用来处理目标文件中名称冲突的问题
- 强弱符号是针对定义而言的，全局变量为强符号，为初始化的全局变量为弱符号

- 符号冲突原则：
  - 多个目标文件中都有强符号，报错
  - 一个目标文件中有强符号，其他都是弱符号，取强符号
  - 都是弱符号，取占用空间最大的...
- 弱符号和弱引用的作用
  - 用户自定义强符号覆盖库中的若符号
  - 用户自定弱符号，判断弱符号是否被覆盖，从而判断是否使用了某个库

### 静态连接

#### 空间地址分配

- 分配可执行文件中的空间和装载到内存中的虚拟地址空间

- 多个目标文件如何合并成一个可执行文件的？
- 各个段是如何合并的？
  - 直接将段放在一起？可行，但是不好。由于字节对齐的原因，每个段都会4096字节对齐
  - 将相似段/相同段合并为一个段。

- 两步链接 Two-pass Linking
  - 空间与地址分配
  - 符号解析与重定位