#### 静态连接

- 在编译目标文件的时候搁置引用其他文件中全局变量的地址，在链接的时候通过符号决议（Symbol Resolution）以及重定位（Relocation）等步骤将符号的地址进行修正
- 疑惑：所有变量都需要重定位吗？肯定不是。如何确定一个变量的地址？栈空间的变量似乎可以确定。堆空间变量的地址是运行时分配的。

#### 目标文件里有什么

- objdump命令与size命令，size命令-A选项使用本地系统格式。查看目标文件头与各个section内容

##### 汇编指令回顾

- 函数参数和函数返回地址保存在caller的函数栈内，callee函数栈的起点保存着caller的%ebp，这也就是函数开头的`push %ebp; mov %esp %ebp`所做的事情。`%ebp`永远指向当前函数栈的起点，也就是最高地址处；而`%esp`则随着`push`和`pop`指令动态变化，永远指向当前函数栈底。
- `call x`指令相当于`push %eip; jump x`，将当前指令地址入栈，并跳转到目标函数地址；同理，`ret`指令也就是`pop %eip`，也就是跳转到当前栈位置的地址中去。

##### .bss段

- 未初始化或者初始化为0的静态变量会被存放在.bss（block started by symbol）段，bss本来是一条指令，用来给未初始化的符号分配空间；初始化了的全局变量则会放在.data段。

##### elf（Executable and Linkable Format）文件结构

- 会有什么呢？
  - magic/类型（可执行/可重定位/动态链接库）/32/64位/大小端/版本/文件头大小
  - 程序入口虚拟地址
  - 段表在文件中的偏移/段表描述符大小/数量
  - 段表字符串表索引（在段表中的序号）

##### 段表 （Section Header Table）

- `objdump -h`显示段信息不全，windows上不知道用啥工具.. linux通常使用`readelf -S`
- `readelf -S`显示的每一行就是一个段描述符`Elf32_Shdr`(Section Header Descriptor)，包括：
  - 段名/类型/标志位
  - 虚拟地址/文件中偏移/段长度
  - 段连接信息
  - 段地址对齐字节数，用指数表示
  - 段中每个项的大小（对项目大小固定的段有用）
  - 重定位表信息作用于哪个段（下标）

- 段的名字无用，有用的是段的类型和标志位

##### 重定位表

- `.rel.text`段，类型为`SHT_REL`即标志该段包含重定位信息。这个名字表明这是针对`.text`段的重定位表，比如对函数的重定位（`printf`等）。`.rel.data`即是针对`.data`段的重定位表，也就是对外部变量的重定位。
- 疑惑？符号表是啥，和重定位表什么关系？

##### 字符串表

- 分为字符串表`.strtab`和段表字符串表`.shstrtab`。前者用来保存普通的字符串，比如变量名；后者用来保存段表中用到的字符串，比如段名
- 疑惑？为何说从ELF头获得了段表字符串表序号后就能够解析整个ELF文件？

##### 符号表

- 函数名/变量名就是**符号**，符号的分类如下：
  - 本目标文件的全局符号，可被其他文件引用。全局函数，全局变量（无static声明）
  - 外部符号。即非本目标文件的符号，引用的全局符号
  - 段名/局部符号/行号信息

- 符号表结构：
  - 符号名（字符串表中的下标）
  - 符号值（在所在段中的偏移/对齐属性/虚拟地址）
  - 符号大小
  - 符号类型和绑定信息（数据/函数/段/文件名）（局部符号/全局符号/弱引用）
  - 符号所在段（可能会有特殊情况，比如文件名/未初始化全局符号，其不在任何一个段中）

##### 符号修饰与函数签名

- 编译器如何区分不同目标文件/命名空间中的同名变量，重载函数? - 符号修饰
- Unix C++中的符号修饰
  - `_ZN5Class4funcEi`
  - `_Z`为所有符号的前缀，如果符号在命名空间/类内，则以`_ZN...E`形式
  - 中间省略处以此写上命名空间的名称，名称写需要写字符串长度
  - c++filt工具可以用来解析修饰过的符号
- 不同编译器生成的修饰符号通常也是不同的，所以不能互相链接！

##### extern "C“

- `extern "C" { stat }`语句块中的部分会被当做C代码处理，其中的符号修饰方式与C++不同。
- 运行库目标文件中的符号自然是以C语言的标准修饰的，C++如果想要兼容C语言的目标文件，就需要将头文件放置在`extern "C" { stat }`代码块中，通常都会用`__cplusplus`宏来处理代码块

##### 强符号/弱符号

- 强弱符号用来处理目标文件中名称冲突的问题
- 强弱符号是针对定义而言的，全局变量为强符号，未初始化的全局变量为弱符号

- 符号冲突原则：
  - 多个目标文件中都有强符号，报错
  - 一个目标文件中有强符号，其他都是弱符号，取强符号
  - 都是弱符号，取占用空间最大的...
- 弱符号和弱引用的作用
  - 用户自定义强符号覆盖库中的若符号
  - 用户自定弱符号，判断弱符号是否被覆盖，从而判断是否使用了某个库

### 静态连接

#### 空间地址分配

- 分配可执行文件中的空间和装载到内存中的虚拟地址空间

- 多个目标文件如何合并成一个可执行文件的？
- 各个段是如何合并的？
  - 直接将段放在一起？可行，但是不好。由于字节对齐的原因，每个段都会4096字节对齐
  - 将相似段/相同段合并为一个段。

- 两步链接 Two-pass Linking
  - 空间与地址分配
  - 符号解析与重定位

#### 符号解析与重定位

- 经过链接之后，原本空置为0x0的地址获得了正确的地址，这是通过重定位表来实现的
- 重定位表是一个`Elf32_Rel`结构的数组，每一项包含：
  - 重定位入口的偏移。相对于段起始的偏移（可重定位文件）/ 入口需要修正的位置的虚拟地址（可执行文件/共享对象文件）。虽说书中还没提到，还是能够理解的，动态链接自然是在运行时刻去查找重定位表来修正地址的，而静态链接在链接时刻就可以确定，所以用的是文件中的偏移。
  - 重定位入口的类型（低8位）的符号表中的下标（高24位）。

- 保留的占位值是什么？
  - 比如引用的是数组中的元素，就会把偏移保留在原位？
  - 符合地址修正的时候会加上符号表中的符号地址信息
  - 如果是相对寻址修正，还需要减去该处位置相对于段的偏移
- 如何判断是相对/绝对寻址修正呢？
  - 通过指令来判断，有的指令接收的就是绝对地址，有的就是相对地址。

#### COMMON块

- 为何不将**未初始化的全局变量**分配在.bss段呢？
  - 因为这是一个弱符号，在链接之前不能知道弱符号的大小因此无法分配空间
  - 多个弱符号冲突的时候会选择大小最大的
  - 最终生成可执行文件的时候还是被放在bss段的

#### C++相关问题

##### 重复代码消除

- 模板/内联函数/虚函数表都会在不同的编译单元里生成相同代码
- 重复代码会有一下问题：
  - 浪费空间
  - 同样的函数指针不相同
  - 缓存命中率降低

- 不同类型实例化的模板函数放在不同的段内，链接的时候取一个
  - 不同的编译单元编译出的结果可能不同.. 链接器会随便选一个，给警告信息

##### 全局构造与析构

- 全局对象的构造函数在main之前被执行，析构函数在main之后被执行

- linux下的程序入口一般是`_start`，其中会调用`main`函数，`.init`段和`.fini`段分别会在`main`前后执行

##### C++与ABI

- 能够链接不同编译器生成的目标文件？
  - 需要链接器能识别这两种格式
  - 两个目标文件需要有相同的符号修饰标准/内存分布方式/函数调用方式等等
  - 这些与可执行代码二进制兼容性相关的内容称为ABI（Application Binary Interface）
    - 内置类型/组合类型的大小和存储方式
    - 外部符号的命名方式和解析方式
    - 函数调用方式/堆栈分布方式/参数传递方式
    - 寄存器使用约定
    - 继承类体系的内存分布
    - 指向成员函数的指针的内存分布
    - 虚表在对象中的位置
    - 模板如何实例化
    - 全局对象的构造和析构
    - 异常的产生和捕获机制
    - RTTI如何实现

#### 静态库链接

- `gcc hello.c -o hello`的执行过程
  - cc1将`hello.c`编译成.s文件
  - as汇编器将其汇编成.o文件
  - 最后调用了collect2完成链接
- collect2可以看作是ld链接器的一个包装
- 为何目标文件中的函数很少？每个.o库中只有一个函数？
  - 不链接未使用的函数

#### 链接过程控制

##### 链接控制脚本

- 怎么来控制链接的过程呢？
  - 命令行参数/PE/COFF中的`.drectve`段/链接控制脚本



### Windows PE/COFF

- Portable Executable/Common Object File Format



### 可执行文件的装载与进程

#### 进程虚拟地址空间

##### PAE(Physical Address Extension)

- 32位CPU能够使用超过4GB的空间？
  - 虚拟地址只能有32位，但是可能通过AWE(Address Windowing Extensions)/mmap映射到2^32之外的空间

#### 装载的方式

##### 覆盖装入 (Overlay)

- 任取程序运行中的一个时刻，当前的调用栈中函数所在模块的集合也就是**调用路径**，确保每个时刻调用路径中的模块都在内存中即可；同时，不在调用路径中的模块也就可以被移出内存。

##### 页映射

- IA32架构处理器一页=4096字节，也就是4KB
- FIFO/LRU...

#### 从操作系统角度看可执行文件的装载

- 创建虚拟地址空间，建立虚拟空间与物理空间的映射关系
  - 本质上只是分配一个页目录（Page Directory)
- 读取文件头，建立虚拟空间与可执行文件的映射关系
  - 虚拟地址的缺页错误，从内存中分配物理页并读取（装载）
  - VMA(Virtual Memeory Area)/(Virtual Section)，及整个映射关系的存放位置

#### 进程虚拟空间分布

##### 文件链接视图和执行视图

- 从不同的角度来理解可执行文件的格式

- section与segment
  - elf文件是以section为单位存储的，但是载入内存空间时，以页大小为单位容易产生冗余空间，因此在可执行文件中，会将类型（读/写/执行）相同的section放在一起形成segment，同一个segment会被一起加载到内存空间中
- Program Header Table
  - 由于目标文件不需要被装载，所以没有该表
  - 类型：LOAD/DYNAMIC/INTERP
  - 文件中的偏移/虚拟地址空间位置/物理装载地址
  - 文件中的段大小/虚拟空间中的段大小/对齐属性
    - 虚拟空间大小如果大于文件中的段大小，额外部分可能就是.bss段，因为其被合并到了.data段，而其唯一区别就是没有初始值，所以不用占用文件空间

##### 堆和栈

- VMA处理可用来映射可执行文件中的Segment之外，还用来管理堆栈、
- Anonymous VMA用来映射堆栈还有vdso，其没有对应的文件
  - 堆向上扩展/栈向下扩展

##### 段地址对齐（仅限ELF格式，PE格式的section都会以页大小对齐，甚至没有segment的概念）

- segment并不是以页大小对齐属性对齐的（但是4字节对齐还是要的），为什么呢？可能每个segment都很小，如果按对齐属性对齐就会浪费空间
- 如果多个segment合并在一起，可以将包含多个segment的那个页重复映射到虚拟地址中即可。这会使得虚拟地址空间增多，但是物理地址空间会节省。

##### 进程栈初始化

- 环境变量/main的参数

#### linux内核装载ELF过程简介

- bash进程会调用fork()系统调用创建一个新的进程；新的进程调用execve()系统调用执行指定的ELF文件；bash进程等待启动的新进程结束。execve的参数也就是文件名/执行参数/环境变量，也就是进程栈初始化中的值
- `execve`调用`sys_execve`检查参数后会调用`do_execve`，`do_execve`会找到可执行文件并检查文件头，用对应格式的装载器来装载文件，efl文件对应的装载函数为`load_elf_binary`，其中:
  - 检查文件有效性
  - 寻找动态链接的`.interp`段
  - 根据programm header table的描述，对ELF文件进行映射
  - 初始化ELF进程环境
  - 将系统调用的返回地址修改为ELF可执行文件的入口点
  - 返回用户态后EIP已经跳转到ELF文件的入口地址，新的程序就开始执行了

#### Windows PE的装载

- 链接器生成可执行文件的时候，会尽量把所有段合并，一般只有代码段/数据段/只读数据段/BSS段这几个

- RVA(Relative Virtual Address)即相对于装载目标地址（Target Address）的偏移

- 装载过程相对ELF文件简单：

  - 先读取第一个页，包含了DOS头，PE文件头和段表
  - 检查进程地址空间中，目标地址是否可用（可执行文件一般都可用，dll文件可能需要rebasing）
  - 使用段表中提供的信息，将PE文件中所有段映射到虚拟空间中的相应位置
  - 装载PE文件所需要的DLL文件
  - 对PE文件中的导入符号进行解析
  - 根据PE头中指定的参数建立和初始化堆栈
  - 建立主线程并启动进程

- PE Optional Header中的一些参数包括

  - 装载地址
  - 程序入口点，即第一条指令的RVA
  - 内存段对齐粒度/文件段对齐粒度

  - 版本/文件大小/头+节表大小/子系统（GUI/控制台）
  - 代码段长度/data段长度/bss段长度
  - 代码段rva/数据段rva

### 动态链接

#### 为什么要动态链接

